---
title: "R PLOTTING - PART1"
author: "Szymon Drobniak"
date: "30/06/2021"
output: rmdformats::robobook
---
```{css, echo=FALSE}
.bluef {
  color: blue;
}

.magf {
  color: magenta;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


**In the below instructions...**

<span class = magf>**EXERCISE 1: **</span> are bits of code to execute/practice pieces to do, often with only hints on how to perform them.

<span class = bluef>**Output**</span> indicates the typical output you should expect from a given instruction.

## Data

We will work on a simple dataset on cholesterol levels from patients. The data presents cholesterol concentrations in plasma in patients before diet, and after 4 & 8 weeks of diet containing one of two types of margarine. The age group of patients is also indicated.

```{r}
data_chol <- read.table('Cholesterol_Age_R.csv',
                       sep = ';', header = T,
                       stringsAsFactors = T)

head(data_chol)
summary(data_chol)
```

## Simple R plot

To represent data graphically we have to asign it to the proper plot axis. The simplest way of plotting data in R is by using a built-in function `plot()`. Variables to plot can be supplied as its arguments, respectively as **x** (horizontal axis) i **y** (vertical axis) - or by supplying one argument, so called formula, des cribing the relationship between the dependent and independent variable, or in other words between x & y as `y ~ x`. Have a look into `?plot()` to learn more. Note, that - depending on the situation - you may have to provide just variable names together with the name of the dataset - using `data = ...` - or to directly call variables in your dataset (e.g. by using `...$variable_x`).

<span class = magf>**EXERCISE 1: **</span>Try to recreate the below plot using the loaded data.

<span class = bluef>**Output**</span>
```{r}
plot(After8weeks ~ Before, data = data_chol,
xlab = "Cholesterol conc. before diet",
ylab = "Cholesterol conc. after 8 weeks",
main = "Change of cholesterol concentration")

### OR

# plot(x = data_chol$Before, y = data_chol$After8weeks,
# xlab = "Cholesterol conc. before diet",
# ylab = "Cholesterol conc. after 8 weeks",
# main = "Change of cholesterol concentration")
```

<span class = magf>**EXERCISE 2: **</span> Zmodyfikuj wykres za pomocą opcji zmieniających kolor i kształt punktów (podpowiedzi znajdziesz tutaj: <https://www.r-graph-gallery.com/6-graph-parameters-reminder.html>). Ustaw symbole w postaci wypełnionych, niebieskich kwadratów.

<span class = bluef>**Output**</span>
```{r}
plot(After8weeks ~ Before, data = data_chol,
xlab = "Stężenie cholesterolu przed eksp.",
ylab = "Stężenie cholesterolu po 8 tyg. eksp.",
main = "Zmiana stężęnia cholesterolu w ciągu 8 tygodni",
pch = 15, col = "blue")
```

<span class = magf>**EXERCISE 3: **</span> Colours and shapes on a plot can be changed at will. Try to experiment in order to recreate the below plot. Note: you have to creat your own data or input it directly into the plotting function. Information about colour codes can be found here: <http://derekogle.com/NCGraphing/resources/colors> - in summary, you can choose them by indicating their names (e.g. `"hotpink"`) or specifying a colour's name in a hexadecimal number system (e.g. `"#AA6574"`).

<span class = bluef>**Output**</span>
```{r}
N <- 11
plot(1:N, rep(1, N), cex = 10, pch = 19,
     col = c('firebrick3', 'orangered', 'orange', 'goldenrod',
             'greenyellow', 'chartreuse', 'springgreen', 'darkturquoise',
             'cornflowerblue', 'mediumblue', 'blueviolet'),
     xlab = 'x', ylab = 'y')

### OR for automated colour generation

plot(1:N, rep(1, N), cex = 10, pch = 19,
     col = rainbow(N),
     xlab = 'x', ylab = 'y')
```

***

histogram is a useful and frequently used type of plot - it can be generated using the `hist()` function.

<span class = magf>**EXERCISE 4: **</span> Create a histogram of 50 ranom samples from a normal distribution with mean 20 and standard deviation 4 (you may want to use the following call `rnorm(50, 20, 4)`).
<span class = bluef>**Output**</span>
```{r}
set.seed(123456789)
vec_data <- rnorm(50, 20, 4)
hist(vec_data)
```

<span class = magf>**EXERCISE 5: **</span> Redo the histogram by increasing the number of binning intervals.
<span class = bluef>**Output**</span> (example)
```{r}
set.seed(123456789)
vec_data <- rnorm(50, 20, 4)
hist(vec_data, 20)
```

<span class = magf>**EXERCISE 6: **</span> instead of a histogram, distributional data can be presented using a smoothed density of data (*kernel density*). You can use the built-in function `density()` to produce such curve, and it can be overlaid on an existing plot using the `lines()` function (similarly, to the `points()` function overlaying points, the `lines()` function does not create a new plot but adds lines to an existing plot ). Try to recreate the above histogram adding to it an overlaid density line:
<span class = bluef>**Output**</span> (example)
```{r}
set.seed(123456789)
vec_data <- rnorm(50, 20, 4)
hist(vec_data, 20, freq = F)
lines(density(vec_data), col = 'red', lwd = 2)
```

## Using `ggplot2`

Control over the graphical parameters in the `plot()` function is rudimentary. The **ggplot2** package gives much more control over how the plots are made and built. The **ggplot2** package is based on so called graphics grammar, a set of rules describing the visual appearance of a plot:

* linking of data to specific elements of a plot (so called **mapping**) is separated from its actual appearance (i.e., **aesthetics**);
* the plot has a layered structure, with latter elements appearing on top of the former ones;
* if possible all plot elements should be built on the go, inside of the plotting code, without the need of modifying/transforming the original data.

A simple *ggplot2* graph may be structured as follows:

```{r eval = FALSE, include = T, echo = T}
mygraph <- ggplot2(data = MYDATA,
                  mapping = aes(x = VAR1, y = VAR2, ...)) +
  geom_1(OPTIONS) +
  geom_2(OPTIONS)

plot(mygraph)

graph2 <- mygraph + geom_3
plot(graph2)
```

Calling the `ggplot()` function may only create an object of class `ggplot` without displaying the actual graph. Such object will contain the data and its mappings to specific elements of the final plot. To display it, we need additional function from the `geom_...` family, which add specific visual elements to the defined mappings (e.g. `geom_point` adds scatterpoints, `geom_hist` forms a histogram). Subsequent elements can be concatenated using the `+` operator. other elements that can be added to the plot using `+` are display and aesthetic rules, e.g. `theme()`, which describe the appearance of non-data elements of a plot.

> *It is a myth that R is incapable of producing a final, publication quality plot that would not have to be modified afterwards :)*

Load the `ggplot2` - if you don;t have it use `install.packages()` to install it.

```{r echo = T}
library(ggplot2)
```

<span class = magf>**EXERCISE 7: **</span> Make a scatterplot similar to one of the previous excersises, mapping the concentrations of cholesterol on the x and y axes. Use blue squares as points. You may want to use the `cex` option to increase the default symbol size (`cex` defines a multiplicative coefficient, that increases or decreases plot elements given number of times).

<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3)
plot1
```

<span class = magf>**EXERCISE 8: **</span> Let's improve the plot by removing the annoying gray background. add the `theme_...()` call to the plot (you can review different predefined versions of it here  <https://ggplot2.tidyverse.org/reference/ggtheme.html>) to produce a cleaner graph.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3) + theme_bw()
plot1
```

<span class = magf>**EXERCISE 9: **</span> Even more aesthetical plot can be produced using the "classic" theme. Try also, by addind the `theme()` definition to the plot, to modify the `text` element using the following formatting: `element_text(size = 20)` - which should increase the default font sizing).
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3) + theme_classic() + theme(text = element_text(size = 20))

### LUB

plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3) + theme_classic(base_size = 20)

### rekomendowana taktyka to modyfikacja warstwy theme()

plot1
```

<span class = magf>**EXERCISE 10: **</span> Add the `geom_smooth` aesthetic to the plot, selecting the `lm` method as its option. Do you know what does `lm` indicate?
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3) + theme_classic() + geom_smooth(method = 'lm') +
  theme(text = element_text(size = 20))
plot1
```
<span class = magf>**EXERCISE 11: **</span> Modify the above call to change the appearance of the regression line.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks)) +
  geom_point(color = 'blue', shape = 15, cex = 3) + theme_classic() + geom_smooth() +
  theme(text = element_text(size = 20))
plot1
```
<span class = magf>**EXERCISE 12: **</span> Try to map the age groups (`AgeGroup`) to the graph points' colours. Using the `alpha` option (taking values 0 - 1 - which indicates the transparency of the regression error band) I decreased the cluttered appearance of the plot, making the error bands a bit more subtle.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks, color = AgeGroup)) +
  geom_point(shape = 15, cex = 3) + theme_classic() + geom_smooth(method = 'lm', alpha = 0.25) +
  theme(text = element_text(size = 20))
plot1
```

<span class = magf>**EXERCISE 12: **</span> let's add the `labs()` layer with a bit more readable axes names.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks, color = AgeGroup)) +
  geom_point(shape = 15, cex = 3) + theme_classic() + geom_smooth(method = 'lm', alpha = 0.25) +
  labs(x = "Concentration before experiment", y = "Concentration after 8 weeks", color = "Age") +
  theme(text = element_text(size = 20))
plot1
```
<span class = magf>**EXERCISE 13: **</span> An alternative way of coding age gropups - instead of mapping it to colours - may be splitting the groups by so called *facets*, which presents subsets of data on separate subplots using a common scale. To achieve this you should use the `facet_wrap()` function, which takes a formula of the form `~ A`, where A indicates a variable from the dataset that defines the split of the graph area into subplots. (An analogous function `facet_grid()` handles well two-sided formulas `A ~ B` that define a grid of plots). Try to recreate the below plot - it may look better with the `theme_bw()` style, instead of the "classic' one.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = After8weeks, color = AgeGroup)) +
  facet_wrap( ~ AgeGroup) +
  geom_point(shape = 15, cex = 3) + theme_bw() + geom_smooth(method = 'lm') +
  labs(x = "Concentration before experiment", y = "Concentration after 8 weeks", color = "Age") +
  theme(text = element_text(size = 20))
plot1
```
<span class = magf>**EXERCISE 14: **</span> Using the `geom_hist()` geometry create a histogram of the `After8weeks` variable.
<span class = bluef>**Output**</span>
```{r}
plot1 <- ggplot(data = data_chol, mapping = aes(x = After8weeks)) +
  geom_histogram(fill = 'white', color = 'black', bins = 10) +
  labs(x = "Concentration after 8 weeks") + theme_classic() +
  theme(text = element_text(size = 20))
plot1
```

<span class = magf>**EXERCISE 15: **</span> Change the histogram so that it displays relative frequencies of data in each bin, and not absolute counts. Inspiration on how to do this can be found here: <https://homepage.divms.uiowa.edu/~luke/classes/STAT4580/histdens.html> - there are at least two ways of achieving this goal!

<span class = bluef>**Output**</span>
```{r}
### this is one of the methods (inside the geom_hist())
plot1 <- ggplot(data = data_chol, mapping = aes(x = After8weeks)) +
  geom_histogram(fill = 'white', color = 'black', bins = 10, aes(y = ..count../sum(..count..))) +
  labs(x = "Concentration after 8 weeks") +theme_classic() +
  theme(text = element_text(size = 20))
plot1
```

<span class = magf>**EXERCISE 16: **</span> Modify the histogram to add a kernel density estimator to it (it is an analogue of the `density()` function we have used earlier).

<span class = bluef>**Output**</span>
```{r}
### This is the second way of turning counts to frequencies in a ggplot2 histogram
plot1 <- ggplot(data = data_chol, mapping = aes(x = Before, y = ..density..)) +
  geom_histogram(fill = 'white', color = 'black', bins = 10) +
  geom_density(color = 'red', fill = 'red', alpha = 0.15) +
  labs(x = "Concentration after 8 weeks") + theme_classic() +
  theme(text = element_text(size = 20))
plot1
```

***
***

## ADDITIONAL EXERCISES

1. `geom_boxplot()` can be used to visualise categorical data. Try to produce such plot, showing the cholesterol concentrations before the diet, categorised by age groups. Use `?geom_boxplot` and if needed the book <https://ggplot2-book.org> to find out how to achieve this. On such boxplot - what is the meaning of: the boundaries of each box, the ends of the whiskers and the additional points added to the plot?

```{r, echo = F}
plot2 <- ggplot(data = data_chol, mapping = aes(x = AgeGroup, y = Before)) +
  geom_boxplot() +
  labs(x = "Age Group", y = "Cholesterol before experiment") +
  theme_classic() + theme(text = element_text(size = 25))
plot2
```

2. A boxplot may be much more informative if we add raw data to it. It can be done in many ways - e.g., to achieve an effect similar to this one; <https://bit.ly/31estrN>. Try to produce a similar plot using additional data (file `Diet_R.csv`, which presents weight loss of patients on three different diets). Before using the data clean it from all missing values (`na.omit()`).

```{r, echo = F}
mydata <- na.omit(read.table("Diet_R.csv", sep = ",", header = T))

plot3 <- ggplot(data = mydata, mapping = aes(x = as.factor(Diet),
                                            color = as.factor(gender),
                                            y = weight6weeks,
                                            fill = as.factor(gender))) +
  geom_boxplot(alpha = 0.3, outlier.shape = NA) + theme_classic() +
  geom_point(color = "black",
             position = position_jitterdodge(jitter.width = 0.1),
             size = 3, alpha = 0.5, stroke = 0) +
  theme(text = element_text(size = 25)) +
  labs(x = "Diet type", y = "Weight after 6 weeks",
       color = "Gender", fill = "Gender")

plot3
```
